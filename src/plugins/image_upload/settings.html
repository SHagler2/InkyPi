<div class="form-group">
    <label for="fitMode" class="form-label">Display Mode</label>
    <select id="fitMode" name="fitMode" class="form-input">
        <option value="fit">Fit (Letterbox - Full image visible)</option>
        <option value="fill">Fill (Crop - No black bars)</option>
        <option value="blur">Blur Background (Full image with blurred fill)</option>
    </select>
    <small style="flex-basis: 100%; margin-top: 2px; color: var(--text-secondary, #888);">
        Fit: Shows entire image with black bars if needed<br>
        Fill: Crops edges to fill screen completely<br>
        Blur: Shows entire image with blurred background fill
    </small>
</div>

<div class="form-group" id="backgroundColorGroup" style="display: none;">
    <label class="form-label" for="backgroundColor">Letterbox Color</label>
    <input type="color" id="backgroundColor" name="backgroundColor" value="#000000" class="color-picker"/>
</div>

<div class="form-group">
    <label for="autoRefresh" class="form-label">Auto-Cycle</label>
    <select id="autoRefresh" name="autoRefresh" class="form-input">
        <option value="0">Off (manual only)</option>
        <option value="1">Every 1 minute</option>
        <option value="5">Every 5 minutes</option>
        <option value="10">Every 10 minutes</option>
        <option value="30">Every 30 minutes</option>
        <option value="60">Every 1 hour</option>
        <option value="240">Every 4 hours</option>
        <option value="1440">Every 24 hours</option>
    </select>
    <small style="flex-basis: 100%; margin-top: 2px; color: var(--text-secondary, #888);">
        Automatically cycle to the next image at this interval
    </small>
</div>

<div class="form-group">
    <label for="randomize" class="form-label">Random Order:</label>
    <div class="toggle-container">
        <input type="checkbox" id="randomize" name="randomize" class="toggle-checkbox" value="false"
            onclick="this.value = this.checked ? 'true' : 'false'">
        <label for="randomize" class="toggle-label"></label>
    </div>
</div>

<div class="form-group">
    <label for="showFilename" class="form-label">Show Filename:</label>
    <div class="toggle-container">
        <input type="checkbox" id="showFilename" name="showFilename" class="toggle-checkbox" value="false"
            onclick="this.value = this.checked ? 'true' : 'false'">
        <label for="showFilename" class="toggle-label"></label>
    </div>
</div>

<div class="form-group">
    <label for="imageUpload" class="form-input file-upload-label" id="uploadLabel">Choose Image</label>
    <input type="file" id="imageUpload" accept="image/*" multiple
           class="file-upload-input" onchange="uploadFiles()">
</div>

<!-- Upload progress -->
<div id="uploadProgress" style="display: none;" class="form-group">
    <div id="uploadStatus" style="color: var(--text-secondary, #888); font-size: 0.9em; padding: 8px 0;"></div>
</div>

<!-- Display uploaded & existing file names -->
<div class="form-group">
    <div id="fileListHeader" style="display: none; justify-content: space-between; align-items: center; margin-bottom: 4px;">
        <span style="font-size: 0.85em; color: var(--text-secondary, #888);" id="fileCount"></span>
        <button type="button" onclick="clearAllFiles()"
            style="background: none; border: none; color: #f44336; font-size: 0.8em; font-weight: 600; cursor: pointer; padding: 2px 6px;">
            Clear All
        </button>
    </div>
    <div id="fileNames" class="file-name-list"></div>
</div>

<!-- Hidden input fields to store file paths -->
<div id="hiddenFileInputs"></div>

<script>
    let uploadsInProgress = 0;

    async function uploadFiles() {
        const fileInput = document.getElementById("imageUpload");
        const files = Array.from(fileInput.files);
        fileInput.value = "";

        if (!files.length) return;

        const progressDiv = document.getElementById("uploadProgress");
        const statusEl = document.getElementById("uploadStatus");
        const uploadLabel = document.getElementById("uploadLabel");
        progressDiv.style.display = "block";

        // Filter out duplicates
        const newFiles = files.filter(f => !document.getElementById(`hidden-${f.name}`));
        if (!newFiles.length) {
            statusEl.textContent = "All files already uploaded";
            setTimeout(() => { progressDiv.style.display = "none"; }, 2000);
            return;
        }

        let total = newFiles.length;
        uploadsInProgress = total;
        uploadLabel.textContent = "Uploading... this might take a few moments";

        // Upload sequentially so progress updates smoothly
        for (let i = 0; i < newFiles.length; i++) {
            const file = newFiles[i];
            statusEl.textContent = `Uploading ${i + 1} / ${total}: ${file.name} (this might take a few moments)`;

            try {
                const formData = new FormData();
                formData.append('file', file);
                const resp = await fetch('/upload_image', { method: 'POST', body: formData });
                const data = await resp.json();
                uploadsInProgress--;
                if (data.success) {
                    addFileToList(data.file_name, data.file_path);
                } else {
                    statusEl.textContent = `Error uploading ${file.name}: ${data.error}`;
                }
            } catch (err) {
                uploadsInProgress--;
                statusEl.textContent = `Failed: ${file.name} - ${err.message}`;
            }
        }

        finishUploadBatch(statusEl, uploadLabel, total);
    }

    function finishUploadBatch(statusEl, uploadLabel, count) {
        statusEl.textContent = `${count} image(s) uploaded`;
        uploadLabel.textContent = "Choose Image";
        setTimeout(() => {
            document.getElementById("uploadProgress").style.display = "none";
        }, 3000);
    }

    function addFileToList(fileName, filePath, missing) {
        const fileNamesDisplay = document.getElementById("fileNames");
        const hiddenFileInputs = document.getElementById("hiddenFileInputs");

        // Don't add if already present
        if (document.getElementById(`hidden-${fileName}`)) return;

        const fileElement = document.createElement("div");
        const missingBadge = missing
            ? '<span style="color: #f44336; font-size: 12px; font-weight: 600; margin-left: 6px;" title="File not found on disk">âš  missing</span>'
            : '';
        fileElement.innerHTML = `
            <span id="fileNameText">${fileName}</span>${missingBadge}
            <button type="button" class="remove-btn" onclick="removeExistingFile('${fileName}')">X</button>
        `;
        fileElement.id = `existing-${fileName}`;
        fileElement.classList.add("file-name");
        if (missing) fileElement.style.opacity = '0.6';
        fileElement.setAttribute('delete-on-submit', '');
        fileNamesDisplay.appendChild(fileElement);

        const hiddenInput = document.createElement("input");
        hiddenInput.type = "hidden";
        hiddenInput.name = "imageFiles[]";
        hiddenInput.value = filePath;
        hiddenInput.id = `hidden-${fileName}`;
        hiddenInput.setAttribute('delete-on-submit', '');
        hiddenFileInputs.appendChild(hiddenInput);

        updateFileListHeader();
    }

    function removeExistingFile(fileName) {
        const hidden = document.getElementById(`hidden-${fileName}`);
        const filePath = hidden ? hidden.value : '';

        // Remove from UI immediately
        const el = document.getElementById(`existing-${fileName}`);
        if (el) el.remove();
        if (hidden) hidden.remove();

        // Delete from disk
        if (filePath) {
            fetch('/delete_image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_path: filePath })
            }).catch(err => console.error('Delete failed:', err));
        }

        updateFileListHeader();
    }

    function clearAllFiles() {
        const hiddenInputs = document.querySelectorAll('#hiddenFileInputs input[name="imageFiles[]"]');
        if (!hiddenInputs.length) return;

        if (!confirm(`Remove all ${hiddenInputs.length} image(s)? Files will be deleted from disk.`)) return;

        // Collect all file paths, then remove from UI and delete from disk
        const filePaths = Array.from(hiddenInputs).map(input => input.value);

        document.getElementById('fileNames').innerHTML = '';
        document.getElementById('hiddenFileInputs').innerHTML = '';

        // Delete all from disk in parallel
        filePaths.forEach(filePath => {
            fetch('/delete_image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_path: filePath })
            }).catch(err => console.error('Delete failed:', err));
        });

        updateFileListHeader();
    }

    function updateFileListHeader() {
        const count = document.querySelectorAll('#hiddenFileInputs input[name="imageFiles[]"]').length;
        const header = document.getElementById('fileListHeader');
        const countEl = document.getElementById('fileCount');
        if (count > 0) {
            header.style.display = 'flex';
            countEl.textContent = `${count} image${count !== 1 ? 's' : ''}`;
        } else {
            header.style.display = 'none';
        }
    }

    // populate form values from plugin settings
    document.addEventListener('DOMContentLoaded', () => {
        const fileNamesDisplay = document.getElementById("fileNames");
        const hiddenFileInputs = document.getElementById("hiddenFileInputs");
        const fitMode = document.getElementById('fitMode');
        const bgColorGroup = document.getElementById('backgroundColorGroup');

        if (loadPluginSettings) {
            // Migrate old padImage setting to new fitMode
            if (pluginSettings.fitMode) {
                fitMode.value = pluginSettings.fitMode;
            } else if (pluginSettings.padImage === 'true') {
                fitMode.value = pluginSettings.backgroundOption === 'blur' ? 'blur' : 'fit';
            } else {
                fitMode.value = 'fit';
            }

            document.getElementById('autoRefresh').value = pluginSettings.autoRefresh || '0';
            document.getElementById('randomize').checked = pluginSettings.randomize === 'true';
            document.getElementById('showFilename').checked = pluginSettings.showFilename === 'true';
            document.getElementById('showFilename').value = pluginSettings.showFilename === 'true' ? 'true' : 'false';
            document.getElementById('backgroundColor').value = pluginSettings.backgroundColor || '#000000';

            // Show color picker for fit mode
            bgColorGroup.style.display = fitMode.value === 'fit' ? 'block' : 'none';

            const existingFiles = pluginSettings['imageFiles[]'] || []

            // Check which files exist on disk, then add with missing indicator
            if (existingFiles.length > 0) {
                fetch('/check_files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_paths: existingFiles })
                })
                .then(resp => resp.json())
                .then(existsMap => {
                    existingFiles.forEach(filePath => {
                        const fileName = filePath.split('/').pop();
                        const missing = existsMap[filePath] === false;
                        addFileToList(fileName, filePath, missing);
                    });
                })
                .catch(() => {
                    // Fallback: add without checking
                    existingFiles.forEach(filePath => {
                        const fileName = filePath.split('/').pop();
                        addFileToList(fileName, filePath, false);
                    });
                });
            }
        }

        // Toggle color picker visibility based on display mode
        fitMode.addEventListener('change', () => {
            bgColorGroup.style.display = fitMode.value === 'fit' ? 'block' : 'none';
        });
    });
</script>
